1. Describe an analogy for relating an algorithm that has efficiency O(1) and another algorithm that has O(2 ^ n).

  An algorithm that has O(1) is a Ferrari and an algorithm that has O(2 ^ n) is a Model T. O(1) is constant time and about as fast as an algorithm can operate, while O(2 ^ n) is exponential time, one of the slowest.

2. In plain English, what is the best case scenario for binary search?

  Binary search's best case performance is constant time, which means that the algorithm will take the same amount of time to run no matter how big it is.

3. In plain English, what is the worst-case scenario for binary search?

  The worst-case is logarithmic time, which means as the size grows, the time will grow faster than constant time but slower than the linear time.

4. In plain English, what is the bounded-case scenario for binary search?

  The bounded case is basically the expected average performance of the algorithm, in this case also logarithmic time. The bounded case is found between the best and worse cases.

5. Create a graph using the data below. Here's a CSV with the values you'll need.

  See graph.png

6. What is the limit of the function above as n approaches infinity?

  The limit is infinity.

7. What is the Big-O of an algorithm that has the data points above?

  It is quadratic time or O(n ^ 2)

8. Write a Ruby method that takes a number n. This method must print the worst-case number of iterations for linear search to find an item in collections of size one to n. Use it to generate a table of worst-case iterations of collections up to size 10.

  def linear_o(n)
    for i in (0..n)
      puts "#{i}, #{i}"
    end
  end

9. Create a graph from the output using Google Sheets or other graphing software. Analyze the graph and denote its Big-O somewhere on the graph.

  See chart.png

10. What is the Big-O of binary search?

  O(log n) or logarithmic time.

11. What is the Big-Ω of binary search?

  Ω(1) or constant time.

12. What is the Big-Ө of binary search?

  Ө(log n) or logarithmic time.
